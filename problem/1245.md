## 1245. Tree Diameter

Given an undirected tree, return its diameter: the number of edges in a longest path in that tree.

The tree is given as an array of edges where edges[i] = [u, v] is a bidirectional edge between nodes u and v.  Each node has labels in the set {0, 1, ..., edges.length}.


### Example
![img1](https://assets.leetcode.com/uploads/2019/06/14/1397_example_1.PNG "img1")
```
Input: edges = [[0,1],[0,2]]
Output: 2
Explanation: 
A longest path of the tree is the path 1 - 0 - 2.
```

![img2](https://assets.leetcode.com/uploads/2019/06/14/1397_example_2.PNG "img2")
```
Input: edges = [[0,1],[1,2],[2,3],[1,4],[4,5]]
Output: 4
Explanation: 
A longest path of the tree is the path 3 - 2 - 1 - 4 - 5.
```
### My Code
```c++
class Solution {
public:
    int dfs(int node, unordered_set<int> visited, unordered_map<int, vector<int>>& mp, int& diameter){
        visited.insert(node);
        int res = 0;
        
        for(auto i : mp[node]){
            if(visited.find(i) != visited.end())
                continue;
            
            int depth = dfs(i, visited, mp, diameter);
            diameter = max(diameter, depth + res);
            res = max(depth, res);
        }
        return node == 0 ? diameter : res+1;
    }
    
    int treeDiameter(vector<vector<int>>& edges) {
        unordered_map<int, vector<int>> mp;
        for(auto e:edges){
            mp[e[0]].push_back(e[1]);
            mp[e[1]].push_back(e[0]);
        }
        
        int ans = 0;
        int diameter = 0;
        unordered_set<int> visited;
        
        return dfs(0, visited, mp, diameter);
        // for(auto m : mp){
        //     
        //     visited.insert(m.first);
        //     ans = max(ans, );
        // }
        
        
        // return ans;
    }
};
```
DFS
Time complexity : O(N)

### Others Solution
```c++
```


