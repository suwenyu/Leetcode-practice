## 317. Shortest Distance from All Buildings

You want to build a house on an empty land which reaches all buildings in the shortest amount of distance. You can only move up, down, left and right. You are given a 2D grid of values 0, 1 or 2, where:

* Each 0 marks an empty land which you can pass by freely.
* Each 1 marks a building which you cannot pass through.
* Each 2 marks an obstacle which you cannot pass through.


### Example
```
Example:

Input: [[1,0,2,0,1],[0,0,0,0,0],[0,0,1,0,0]]

1 - 0 - 2 - 0 - 1
|   |   |   |   |
0 - 0 - 0 - 0 - 0
|   |   |   |   |
0 - 0 - 1 - 0 - 0

Output: 7 

Explanation: Given three buildings at (0,0), (0,4), (2,2), and an obstacle at (0,2),
             the point (1,2) is an ideal empty land to build a house, as the total 
             travel distance of 3+3+1=7 is minimal. So return 7.
```

### My Code
```c++
class Solution {
public:
    vector<pair<int, int>>dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    
    void helper(int minDist, int i, int j, vector<vector<int>>& total, vector<vector<int>>& grid, int walk){

    }
    
    int shortestDistance(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        auto total = grid;
        int walk = 0, minDist;
        
        for(int i = 0; i < m ; i++){
            for(int j = 0 ; j < n; j++){
                if(grid[i][j] == 1){
                            minDist = -1;
                            auto dist = grid;
                            queue<pair<int, int>>q;
                            q.emplace(i, j);
                            while(!q.empty()){
                                auto ij = q.front();
                                q.pop();
                                for(int d = 0; d < 4; d++){
                                    int i = ij.first + dir[d].first;
                                    int j = ij.second + dir[d].second;

                                    if (i >= 0 && i < grid.size() && j >= 0 && j < grid[0].size() && grid[i][j] == walk) {
                                        grid[i][j]--;
                                        dist[i][j] = dist[ij.first][ij.second] + 1;
                                        total[i][j] += dist[i][j] -1;
                                        q.emplace(i, j);
                                        if(minDist < 0 || minDist > total[i][j])
                                            minDist = total[i][j];
                                    }
                                }
                            }
                            walk--;
                }
            }
        }
        
        return minDist;
    }
};
```


### Others Solution
```c++
```

