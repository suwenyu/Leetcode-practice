## 1332. Remove Palindromic Subsequences

Given a string s consisting only of letters 'a' and 'b'. In a single step you can remove one palindromic subsequence from s.

Return the minimum number of steps to make the given string empty.

A string is a subsequence of a given string, if it is generated by deleting some characters of a given string without changing its order.

A string is called palindrome if is one that reads the same backward as well as forward.


### Example
```
Example 1:

Input: s = "ababa"
Output: 1
Explanation: String is already palindrome


Example 2:

Input: s = "abb"
Output: 2
Explanation: "abb" -> "bb" -> "". 
Remove palindromic subsequence "a" then "bb".


Example 3:

Input: s = "baabb"
Output: 2
Explanation: "baabb" -> "b" -> "". 
Remove palindromic subsequence "baab" then "b".


Example 4:

Input: s = ""
Output: 0
```

### My Code
```c++
class Solution {
public:
    int removePalindromeSub(string s) {
        int ans = 0;
        
        while(s != ""){
            ans++;
            
            int j = s.size()-1;
            unordered_set<int> removed;
            for(int i = 0 ; i < s.size() ; i++){
                while(j > i && s[i] != s[j]){
                    j--;
                }
                if(j > i){
                    removed.insert(i);
                    removed.insert(j);
                    // cout << "test - ";
                    j--;
                }

                if(j == i && s[i] == s[j]){
                    removed.insert(i);
                    // cout << "test1\n";
                }
                // cout << i << " " << j << endl;
            }

            string new_s = "";
            for(int i = 0 ; i < s.size() ; i++){
                if(removed.find(i) == removed.end())
                    new_s += s[i];
            }
            s = new_s;
        }
        // cout << new_s << endl;
        
        return ans;
    }
};
```
wrong answer...
think too much

### Others Solution
```c++
class Solution {
public:
    bool ispalindrome(string s){
        int left, right = s.size()-1;
        for(left = 0 ; left < s.size()/2 + 1 ; left++){
            if(s[left] != s[right])
                return false;
            // cout << left << " " << right << endl;
            right--;
        }
        return true;
    }
    
    int removePalindromeSub(string s) {
        if(s.size() == 0)
            return 0;
        else if(ispalindrome(s))
            return 1;
        
        return 2;
    }
};
```
其實只有三種情況：
1. 空字串： 回傳 0
2. 假如已經是回文： 回傳 1
3. 其餘：都可以先移除a 再移除b（兩步能解決）

time complexity : O(N)